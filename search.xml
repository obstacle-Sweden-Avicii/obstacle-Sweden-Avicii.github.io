<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图片无法加载解决方法</title>
    <url>/2024/11/30/1.%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<hr>
<h2 id="1-图片"><a href="#1-图片" class="headerlink" title="1.图片"></a>1.图片</h2><p>往typora插入图片，图片文件夹一定要和创建的.md文件夹放在同一个文件夹下。不然文件移动位置后图片会因找不到地址而消失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式！[提示文字](图片地址)      即先！然后快捷键ctrl+k</span><br><span class="line">例如：![伊雷娜](D:\blog\source\images\Elaina.jpg)</span><br></pre></td></tr></table></figure>

<p><img src="/1.%E5%9B%BE%E7%89%87/20230722_142715593_iOS.jpg" alt="伊雷娜"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>相信很多人尝试上面图片的插入方法会遇到在typora能正常显示图片，但在网页上图片却无法加载。这是因为上述地址如D:\blog\source\images\Elaina.jpg为本地地址，而hexo+github搭建的博客并不能访问本地地址所以自然无法成功。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>最简单粗暴的方法就是直接将图片拖到typora中，typora会直接创建博客文章同名的文件夹存放图片。但是就是感觉文章写多了有点乱乱的。</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法学习</title>
    <url>/2025/01/18/kmp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>前言：前段时间在写pta上面的代码题时遇到一个查找字符串字串的问题，一开始采取i，j循环遍历的方法暴力寻找，但是很可惜时间复杂度上出现问题，于是经过学习，初步尝试运用kmp算法来解决查找字符串字串中时间复杂度的问题。</p>
<p>对kmp的名称由来等就不展开描述了直接进入代码部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray</span><span class="params">(<span class="type">char</span>* pat, <span class="type">int</span> M, <span class="type">int</span>* lps)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>,i=<span class="number">1</span>;  <span class="comment">// 当前最长前缀后缀长度</span></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// lps[0] 总是为 0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[i] == pat[len]) </span><br><span class="line">        &#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>)   <span class="comment">// 不匹配时，根据 lps 数组更新 len</span></span><br><span class="line">            &#123;</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lps[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMPSearch</span><span class="params">(<span class="type">char</span>* pat, <span class="type">char</span>* txt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> M = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="type">int</span> N = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="type">int</span>* lps = (<span class="type">int</span>*)<span class="built_in">malloc</span>(M * <span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 创建 lps 数组</span></span><br><span class="line">    <span class="built_in">computeLPSArray</span>(pat, M, lps);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// txt 的索引</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// pat 的索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[j] == txt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到模式字符串 &#x27;%s&#x27; 的起始位置: %d\n&quot;</span>, pat, i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; N &amp;&amp; pat[j] != txt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>)   <span class="comment">// 字符不匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> txt[] = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">char</span> pat[] = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    <span class="built_in">KMPSearch</span>(pat, txt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人理解，掌握kmp算法的关键就是掌握lps数组的构造（网上大部分也称next数组，就把lps换成next），lps数组也就是找字串中的最大公共前后缀，它可以帮助我们查找子串时优化“回溯”过程，因为用i，j单纯暴力循环每次都要回到最初会有很多浪费，利用lps数组的构造就可以优化这个过程。具体概念理解，以及构造思路还需要在网络上自己找视频理解。</p>
<p>接下来是pta里面的一道题，运用kmp算法解决。</p>
<p><strong>7-11 删除字符串中的子串</strong></p>
<p>分数 10</p>
<p>作者 白洪欢</p>
<p>单位 浙江大学</p>
<p>输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tomcat is a male ccatat</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tom is a male </span><br></pre></td></tr></table></figure>

<p>下面是通过代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 计算LPS（最长前缀后缀）数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeLPSArray</span><span class="params">(<span class="type">char</span>* pat, <span class="type">int</span> M, <span class="type">int</span>* lps)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// 当前最长前缀长度</span></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// lps[0] 总是为 0</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 从 lps[1] 开始计算</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[i] == pat[len]) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">                len = lps[len - <span class="number">1</span>]; <span class="comment">// 根据 lps 更新 len</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lps[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// KMP搜索算法 - 查找并删除所有出现的子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMPSearchAndDelete</span><span class="params">(<span class="type">char</span>* txt, <span class="type">char</span>* pat)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> M = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="type">int</span> N = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="type">int</span>* lps = (<span class="type">int</span>*)<span class="built_in">malloc</span>(M * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">computeLPSArray</span>(pat, M, lps);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串的索引</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串的索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pat[j] == txt[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == M) &#123;</span><br><span class="line">            <span class="comment">// 找到一个匹配，删除子串</span></span><br><span class="line">            <span class="built_in">memmove</span>(&amp;txt[i - j], &amp;txt[i], N - i + <span class="number">1</span>); <span class="comment">// 移动后面的字符</span></span><br><span class="line">            N -= j; <span class="comment">// 更新主串长度</span></span><br><span class="line">            txt[N] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保以&#x27;\0&#x27;结束</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重置j为0，继续寻找进一步的匹配</span></span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            i = <span class="number">0</span>; <span class="comment">// 从头再继续检查</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; N &amp;&amp; pat[j] != txt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = lps[j - <span class="number">1</span>]; <span class="comment">// 根据lps调整j</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(lps); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">256</span>]; <span class="comment">// 增大数组大小以容纳更长的字符串</span></span><br><span class="line">    <span class="type">char</span> s2[<span class="number">81</span>];</span><br><span class="line">    <span class="built_in">fgets</span>(s1, <span class="built_in">sizeof</span>(s1), stdin);</span><br><span class="line">    s1[<span class="built_in">strcspn</span>(s1, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line">    <span class="built_in">fgets</span>(s2, <span class="built_in">sizeof</span>(s2), stdin);</span><br><span class="line">    s2[<span class="built_in">strcspn</span>(s2, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>; <span class="comment">// 去掉换行符</span></span><br><span class="line">    <span class="comment">// 持续删除子串直到找不到为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strstr</span>(s1, s2) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">KMPSearchAndDelete</span>(s1, s2); <span class="comment">// 查找并删除子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2024/11/03/blog/</url>
    <content><![CDATA[<p>这是我的第一个博客</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>typora测试尝试</title>
    <url>/2024/11/21/typora%E5%8A%9F%E8%83%BD%E5%88%9D%E6%AD%A5%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="typora功能初步尝试"><a href="#typora功能初步尝试" class="headerlink" title="typora功能初步尝试"></a>typora功能初步尝试</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>一级标题：ctrl+1或#<br>二级标题：ctrl+2或##<br>剩下的三级四级等就可以以此类推了</p>
<h2 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h2><p>删除线：alt+shift+5    示例   ~~~~<br>加粗：ctrl+B 示例  <strong>加粗</strong><br>斜体：ctrl+I 示例  <em>斜体</em><br>下划线：ctrl+U 示例 <u>下划线</u><br>高亮：&#x3D;&#x3D;中间内容&#x3D;&#x3D;</p>
<h2 id="3-表情包"><a href="#3-表情包" class="headerlink" title="3.表情包"></a>3.表情包</h2><p>:smile: :100: :heart:  快捷键:windows+；    </p>
<h2 id="4-表格"><a href="#4-表格" class="headerlink" title="4.表格"></a>4.表格</h2><table>
<thead>
<tr>
<th>week2</th>
<th>week3</th>
<th>week4</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>快捷键:ctrl+t</p>
<h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><blockquote>
<p>一级应用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>瑞典厨师长</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">插入不确定代码，快捷键：ctrl+shift+k</span><br></pre></td></tr></table></figure>

<h2 id="7-分隔线"><a href="#7-分隔线" class="headerlink" title="7.分隔线"></a>7.分隔线</h2><hr>
<p>***  然后回车</p>
<h2 id="8-源代码模式"><a href="#8-源代码模式" class="headerlink" title="8.源代码模式"></a>8.源代码模式</h2><p>ctrl+&#x2F;,退出一样</p>
<h2 id="9-跳转"><a href="#9-跳转" class="headerlink" title="9.跳转"></a>9.跳转</h2><h4 id="1-跳转到外部"><a href="#1-跳转到外部" class="headerlink" title="1.跳转到外部"></a>1.跳转到外部</h4><p><a href="https://www.bilibili.com/">bilibili</a><br><a href="obstacle.top">屑魔女的个人博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+k      格式[提示文字](网址)</span><br></pre></td></tr></table></figure>

<h4 id="2-跳转到内部"><a href="#2-跳转到内部" class="headerlink" title="2.跳转到内部"></a>2.跳转到内部</h4><p>[博客](#<a href="http://localhost:4000/2024/11/03/blog/">my first blog</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快捷键：CTRL+k     [提示文字](#标题)</span><br></pre></td></tr></table></figure>

<h2 id="10-自动链接"><a href="#10-自动链接" class="headerlink" title="10.自动链接"></a>10.自动链接</h2><p>使用&lt;&gt;然后括号里链接会自动转化为超链接</p>
<h2 id="11-图片"><a href="#11-图片" class="headerlink" title="11.图片"></a>11.图片</h2><p>往typora插入图片，图片文件夹一定要和创建的.md文件夹放在同一个文件夹下。不然文件移动位置后图片会因找不到地址而消失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式！[提示文字](图片地址)      即先！然后快捷键ctrl+k</span><br><span class="line">例如：![伊雷娜](D:\blog\source\images\Elaina.jpg)</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5CElaina.jpg" alt="伊蕾娜"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>typora测试</title>
    <url>/2024/11/21/typora%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>尝试用typora写一篇博客，此文章仅做测试使用</p>
]]></content>
  </entry>
  <entry>
    <title>hgame 2025 week2 crypto</title>
    <url>/2025/02/18/hgame2025week2%20crypto/</url>
    <content><![CDATA[<p>总结一下hgame week2crypto部分。自己虽然学了一段时间，结果week1密码一道没做出来，还是非常遗憾的，所幸week2密码是ak了的</p>
<h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="1-ancient-recall"><a href="#1-ancient-recall" class="headerlink" title="1.ancient recall"></a>1.ancient recall</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">Major_Arcana = [<span class="string">&quot;The Fool&quot;</span>, <span class="string">&quot;The Magician&quot;</span>, <span class="string">&quot;The High Priestess&quot;</span>,<span class="string">&quot;The Empress&quot;</span>, <span class="string">&quot;The Emperor&quot;</span>, <span class="string">&quot;The Hierophant&quot;</span>,<span class="string">&quot;The Lovers&quot;</span>, <span class="string">&quot;The Chariot&quot;</span>, <span class="string">&quot;Strength&quot;</span>,<span class="string">&quot;The Hermit&quot;</span>, <span class="string">&quot;Wheel of Fortune&quot;</span>, <span class="string">&quot;Justice&quot;</span>,<span class="string">&quot;The Hanged Man&quot;</span>, <span class="string">&quot;Death&quot;</span>, <span class="string">&quot;Temperance&quot;</span>,<span class="string">&quot;The Devil&quot;</span>, <span class="string">&quot;The Tower&quot;</span>, <span class="string">&quot;The Star&quot;</span>,<span class="string">&quot;The Moon&quot;</span>, <span class="string">&quot;The Sun&quot;</span>, <span class="string">&quot;Judgement&quot;</span>,<span class="string">&quot;The World&quot;</span>]</span><br><span class="line">wands = [<span class="string">&quot;Ace of Wands&quot;</span>, <span class="string">&quot;Two of Wands&quot;</span>, <span class="string">&quot;Three of Wands&quot;</span>, <span class="string">&quot;Four of Wands&quot;</span>, <span class="string">&quot;Five of Wands&quot;</span>, <span class="string">&quot;Six of Wands&quot;</span>, <span class="string">&quot;Seven of Wands&quot;</span>, <span class="string">&quot;Eight of Wands&quot;</span>, <span class="string">&quot;Nine of Wands&quot;</span>, <span class="string">&quot;Ten of Wands&quot;</span>, <span class="string">&quot;Page of Wands&quot;</span>, <span class="string">&quot;Knight of Wands&quot;</span>, <span class="string">&quot;Queen of Wands&quot;</span>, <span class="string">&quot;King of Wands&quot;</span>]</span><br><span class="line">cups = [<span class="string">&quot;Ace of Cups&quot;</span>, <span class="string">&quot;Two of Cups&quot;</span>, <span class="string">&quot;Three of Cups&quot;</span>, <span class="string">&quot;Four of Cups&quot;</span>, <span class="string">&quot;Five of Cups&quot;</span>, <span class="string">&quot;Six of Cups&quot;</span>, <span class="string">&quot;Seven of Cups&quot;</span>, <span class="string">&quot;Eight of Cups&quot;</span>, <span class="string">&quot;Nine of Cups&quot;</span>, <span class="string">&quot;Ten of Cups&quot;</span>, <span class="string">&quot;Page of Cups&quot;</span>, <span class="string">&quot;Knight of Cups&quot;</span>, <span class="string">&quot;Queen of Cups&quot;</span>, <span class="string">&quot;King of Cups&quot;</span>]</span><br><span class="line">swords = [<span class="string">&quot;Ace of Swords&quot;</span>, <span class="string">&quot;Two of Swords&quot;</span>, <span class="string">&quot;Three of Swords&quot;</span>, <span class="string">&quot;Four of Swords&quot;</span>, <span class="string">&quot;Five of Swords&quot;</span>, <span class="string">&quot;Six of Swords&quot;</span>, <span class="string">&quot;Seven of Swords&quot;</span>, <span class="string">&quot;Eight of Swords&quot;</span>, <span class="string">&quot;Nine of Swords&quot;</span>, <span class="string">&quot;Ten of Swords&quot;</span>, <span class="string">&quot;Page of Swords&quot;</span>, <span class="string">&quot;Knight of Swords&quot;</span>, <span class="string">&quot;Queen of Swords&quot;</span>, <span class="string">&quot;King of Swords&quot;</span>]</span><br><span class="line">pentacles = [<span class="string">&quot;Ace of Pentacles&quot;</span>, <span class="string">&quot;Two of Pentacles&quot;</span>, <span class="string">&quot;Three of Pentacles&quot;</span>, <span class="string">&quot;Four of Pentacles&quot;</span>, <span class="string">&quot;Five of Pentacles&quot;</span>, <span class="string">&quot;Six of Pentacles&quot;</span>, <span class="string">&quot;Seven of Pentacles&quot;</span>, <span class="string">&quot;Eight of Pentacles&quot;</span>, <span class="string">&quot;Nine of Pentacles&quot;</span>, <span class="string">&quot;Ten of Pentacles&quot;</span>, <span class="string">&quot;Page of Pentacles&quot;</span>, <span class="string">&quot;Knight of Pentacles&quot;</span>, <span class="string">&quot;Queen of Pentacles&quot;</span>, <span class="string">&quot;King of Pentacles&quot;</span>]</span><br><span class="line">Minor_Arcana = wands + cups + swords + pentacles</span><br><span class="line">tarot = Major_Arcana + Minor_Arcana</span><br><span class="line">reversals = [<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Value = []</span><br><span class="line">cards = []</span><br><span class="line">YOUR_initial_FATE = []</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(YOUR_initial_FATE)&lt;<span class="number">5</span>:</span><br><span class="line">    card = random.choice(tarot)</span><br><span class="line">    <span class="keyword">if</span> card <span class="keyword">not</span> <span class="keyword">in</span> cards:</span><br><span class="line">        cards.append(card)</span><br><span class="line">        <span class="keyword">if</span> card <span class="keyword">in</span> Major_Arcana:</span><br><span class="line">            k = random.choice(reversals)</span><br><span class="line">            Value.append(tarot.index(card)^k)</span><br><span class="line">            <span class="keyword">if</span> k == -<span class="number">1</span>:</span><br><span class="line">                YOUR_initial_FATE.append(<span class="string">&quot;re-&quot;</span>+card)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                YOUR_initial_FATE.append(card)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Value.append(tarot.index(card))</span><br><span class="line">            YOUR_initial_FATE.append(card)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Oops!lets reverse 1T!&quot;</span>)</span><br><span class="line"></span><br><span class="line">FLAG=(<span class="string">&quot;hgame&#123;&quot;</span>+<span class="string">&quot;&amp;&quot;</span>.join(YOUR_initial_FATE)+<span class="string">&quot;&#125;&quot;</span>).replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;_&quot;</span>)</span><br><span class="line"></span><br><span class="line">YOUR_final_Value = Value</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fortune_wheel</span>(<span class="params">FATE</span>):</span><br><span class="line">    FATEd = [FATE[i]+FATE[(i+<span class="number">1</span>)%<span class="number">5</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(FATE))]</span><br><span class="line">    <span class="keyword">return</span> FATEd</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">250</span>):</span><br><span class="line">    YOUR_final_Value = Fortune_wheel(YOUR_final_Value)</span><br><span class="line"><span class="built_in">print</span>(YOUR_final_Value)</span><br><span class="line">YOUR_final_FATE = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> YOUR_final_Value:</span><br><span class="line">    YOUR_final_FATE.append(tarot[i%<span class="number">78</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your destiny changed!\n&quot;</span>,<span class="string">&quot;,&quot;</span>.join(YOUR_final_FATE))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;oh,now you GET th3 GOOd lU&gt;k,^^&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Oops!lets reverse 1T!</span></span><br><span class="line"><span class="string">[2532951952066291774890498369114195917240794704918210520571067085311474675019, 2532951952066291774890327666074100357898023013105443178881294700381509795270, 2532951952066291774890554459287276604903130315859258544173068376967072335730, 2532951952066291774890865328241532885391510162611534514014409174284299139015, 2532951952066291774890830662608134156017946376309989934175833913921142609334]</span></span><br><span class="line"><span class="string">Your destiny changed!</span></span><br><span class="line"><span class="string"> Eight of Cups,Ace of Cups,Strength,The Chariot,Five of Swords</span></span><br><span class="line"><span class="string">oh,now you GET th3 GOOd lU&gt;k,^^</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>emmmm,自己看不太懂，但题目应该比较简单，丢给ai直接解出来（</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Major_Arcana = [<span class="string">&quot;The Fool&quot;</span>, <span class="string">&quot;The Magician&quot;</span>, <span class="string">&quot;The High Priestess&quot;</span>,<span class="string">&quot;The Empress&quot;</span>, <span class="string">&quot;The Emperor&quot;</span>, <span class="string">&quot;The Hierophant&quot;</span>,<span class="string">&quot;The Lovers&quot;</span>, <span class="string">&quot;The Chariot&quot;</span>, <span class="string">&quot;Strength&quot;</span>,<span class="string">&quot;The Hermit&quot;</span>, <span class="string">&quot;Wheel of Fortune&quot;</span>, <span class="string">&quot;Justice&quot;</span>,<span class="string">&quot;The Hanged Man&quot;</span>, <span class="string">&quot;Death&quot;</span>, <span class="string">&quot;Temperance&quot;</span>,<span class="string">&quot;The Devil&quot;</span>, <span class="string">&quot;The Tower&quot;</span>, <span class="string">&quot;The Star&quot;</span>,<span class="string">&quot;The Moon&quot;</span>, <span class="string">&quot;The Sun&quot;</span>, <span class="string">&quot;Judgement&quot;</span>,<span class="string">&quot;The World&quot;</span>]</span><br><span class="line">wands = [<span class="string">&quot;Ace of Wands&quot;</span>, <span class="string">&quot;Two of Wands&quot;</span>, <span class="string">&quot;Three of Wands&quot;</span>, <span class="string">&quot;Four of Wands&quot;</span>, <span class="string">&quot;Five of Wands&quot;</span>, <span class="string">&quot;Six of Wands&quot;</span>, <span class="string">&quot;Seven of Wands&quot;</span>, <span class="string">&quot;Eight of Wands&quot;</span>, <span class="string">&quot;Nine of Wands&quot;</span>, <span class="string">&quot;Ten of Wands&quot;</span>, <span class="string">&quot;Page of Wands&quot;</span>, <span class="string">&quot;Knight of Wands&quot;</span>, <span class="string">&quot;Queen of Wands&quot;</span>, <span class="string">&quot;King of Wands&quot;</span>]</span><br><span class="line">cups = [<span class="string">&quot;Ace of Cups&quot;</span>, <span class="string">&quot;Two of Cups&quot;</span>, <span class="string">&quot;Three of Cups&quot;</span>, <span class="string">&quot;Four of Cups&quot;</span>, <span class="string">&quot;Five of Cups&quot;</span>, <span class="string">&quot;Six of Cups&quot;</span>, <span class="string">&quot;Seven of Cups&quot;</span>, <span class="string">&quot;Eight of Cups&quot;</span>, <span class="string">&quot;Nine of Cups&quot;</span>, <span class="string">&quot;Ten of Cups&quot;</span>, <span class="string">&quot;Page of Cups&quot;</span>, <span class="string">&quot;Knight of Cups&quot;</span>, <span class="string">&quot;Queen of Cups&quot;</span>, <span class="string">&quot;King of Cups&quot;</span>]</span><br><span class="line">swords = [<span class="string">&quot;Ace of Swords&quot;</span>, <span class="string">&quot;Two of Swords&quot;</span>, <span class="string">&quot;Three of Swords&quot;</span>, <span class="string">&quot;Four of Swords&quot;</span>, <span class="string">&quot;Five of Swords&quot;</span>, <span class="string">&quot;Six of Swords&quot;</span>, <span class="string">&quot;Seven of Swords&quot;</span>, <span class="string">&quot;Eight of Swords&quot;</span>, <span class="string">&quot;Nine of Swords&quot;</span>, <span class="string">&quot;Ten of Swords&quot;</span>, <span class="string">&quot;Page of Swords&quot;</span>, <span class="string">&quot;Knight of Swords&quot;</span>, <span class="string">&quot;Queen of Swords&quot;</span>, <span class="string">&quot;King of Swords&quot;</span>]</span><br><span class="line">pentacles = [<span class="string">&quot;Ace of Pentacles&quot;</span>, <span class="string">&quot;Two of Pentacles&quot;</span>, <span class="string">&quot;Three of Pentacles&quot;</span>, <span class="string">&quot;Four of Pentacles&quot;</span>, <span class="string">&quot;Five of Pentacles&quot;</span>, <span class="string">&quot;Six of Pentacles&quot;</span>, <span class="string">&quot;Seven of Pentacles&quot;</span>, <span class="string">&quot;Eight of Pentacles&quot;</span>, <span class="string">&quot;Nine of Pentacles&quot;</span>, <span class="string">&quot;Ten of Pentacles&quot;</span>, <span class="string">&quot;Page of Pentacles&quot;</span>, <span class="string">&quot;Knight of Pentacles&quot;</span>, <span class="string">&quot;Queen of Pentacles&quot;</span>, <span class="string">&quot;King of Pentacles&quot;</span>]</span><br><span class="line">Minor_Arcana = wands + cups + swords + pentacles</span><br><span class="line">tarot = Major_Arcana + Minor_Arcana</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_step</span>(<span class="params">B</span>):</span><br><span class="line">    B0, B1, B2, B3, B4 = B</span><br><span class="line">    numerator = B0 + B1 + B3 - B2 - B4</span><br><span class="line">    <span class="keyword">if</span> numerator % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;奇数无法整除&quot;</span>)</span><br><span class="line">    A1 = numerator // <span class="number">2</span></span><br><span class="line">    A0 = B0 - A1</span><br><span class="line">    A2 = B1 - A1</span><br><span class="line">    A3 = B2 - A2</span><br><span class="line">    A4 = B3 - A3</span><br><span class="line">    <span class="keyword">if</span> A4 + A0 != B4:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;验证失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [A0, A1, A2, A3, A4]</span><br><span class="line">final_values = [</span><br><span class="line">    <span class="number">2532951952066291774890498369114195917240794704918210520571067085311474675019</span>,</span><br><span class="line">    <span class="number">2532951952066291774890327666074100357898023013105443178881294700381509795270</span>,</span><br><span class="line">    <span class="number">2532951952066291774890554459287276604903130315859258544173068376967072335730</span>,</span><br><span class="line">    <span class="number">2532951952066291774890865328241532885391510162611534514014409174284299139015</span>,</span><br><span class="line">    <span class="number">2532951952066291774890830662608134156017946376309989934175833913921142609334</span></span><br><span class="line">]</span><br><span class="line">current = final_values.copy()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">250</span>):</span><br><span class="line">    current = reverse_step(current)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_card</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">        <span class="keyword">if</span> k ^ -<span class="number">1</span> == v:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;re-<span class="subst">&#123;Major_Arcana[k]&#125;</span>&quot;</span></span><br><span class="line">    index = v % <span class="number">78</span></span><br><span class="line">    card = tarot[index]</span><br><span class="line">    <span class="keyword">if</span> card <span class="keyword">in</span> Major_Arcana <span class="keyword">and</span> v == index:</span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line">    <span class="keyword">return</span> card</span><br><span class="line">cards = [get_card(v) <span class="keyword">for</span> v <span class="keyword">in</span> current]</span><br><span class="line">flag = <span class="string">&quot;hgame&#123;&quot;</span> + <span class="string">&quot;&amp;&quot;</span>.join(cards).replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#hgame&#123;re-The_Moon&amp;re-The_Sun&amp;Judgement&amp;re-Temperance&amp;Six_of_Cups&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Intergalactic-Bound"><a href="#2-Intergalactic-Bound" class="headerlink" title="2.Intergalactic Bound"></a>2.Intergalactic Bound</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_THCurve</span>(<span class="params">P, Q</span>):</span><br><span class="line">    <span class="keyword">if</span> P == (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> Q</span><br><span class="line">    <span class="keyword">if</span> Q == (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> P</span><br><span class="line">    x1, y1 = P</span><br><span class="line">    x2, y2 = Q</span><br><span class="line">    x3 = (x1 - y1 ** <span class="number">2</span> * x2 * y2) * <span class="built_in">pow</span>(a * x1 * y1 * x2 ** <span class="number">2</span> - y2, -<span class="number">1</span>, p) % p</span><br><span class="line">    y3 = (y1 * y2 ** <span class="number">2</span> - a * x1 ** <span class="number">2</span> * x2) * <span class="built_in">pow</span>(a * x1 * y1 * x2 ** <span class="number">2</span> - y2, -<span class="number">1</span>, p) % p</span><br><span class="line">    <span class="keyword">return</span> x3, y3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul_THCurve</span>(<span class="params">n, P</span>):</span><br><span class="line">    R = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            R = add_THCurve(R, P)</span><br><span class="line">        P = add_THCurve(P, P)</span><br><span class="line">        n = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">96</span>)</span><br><span class="line">a = randint(<span class="number">1</span>, p)</span><br><span class="line">G = (randint(<span class="number">1</span>,p), randint(<span class="number">1</span>,p))</span><br><span class="line">d = (a*G[<span class="number">0</span>]^<span class="number">3</span>+G[<span class="number">1</span>]^<span class="number">3</span>+<span class="number">1</span>)%p*inverse(G[<span class="number">0</span>]*G[<span class="number">1</span>],p)%p</span><br><span class="line">x = randint(<span class="number">1</span>, p)</span><br><span class="line">Q = mul_THCurve(x, G)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;G = <span class="subst">&#123;G&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Q = <span class="subst">&#123;Q&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = hashlib.sha256(<span class="built_in">str</span>(x).encode()).digest()</span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = pad(flag,<span class="number">16</span>)</span><br><span class="line">ciphertext = cipher.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ciphertext=<span class="subst">&#123;ciphertext&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 55099055368053948610276786301</span></span><br><span class="line"><span class="string">G = (19663446762962927633037926740, 35074412430915656071777015320)</span></span><br><span class="line"><span class="string">Q = (26805137673536635825884330180, 26376833112609309475951186883)</span></span><br><span class="line"><span class="string">ciphertext=b&quot;k\xe8\xbe\x94\x9e\xfc\xe2\x9e\x97\xe5\xf3\x04&#x27;\x8f\xb2\x01T\x06\x88\x04\xeb3Jl\xdd Pk$\x00:\xf5&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>add_THcurve部分符合符合<a href="https://www.hyperelliptic.org/EFD/g1p/auto-twistedhessian.html">https://www.hyperelliptic.org/EFD/g1p/auto-twistedhessian.html</a> 的定义。 所以按照文章里套换元 x’&#x3D;X&#x2F;Z y’&#x3D;Y&#x2F;Z 得到 a<em>x’^3+y’^3+z’^3&#x3D;d</em>x’<em>y’</em>z’这样构造出了齐次式子之后就可以构造椭圆曲线了。所以现在只需要求a的值即可代入脚本求解。因为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = (a*G[<span class="number">0</span>]^<span class="number">3</span>+G[<span class="number">1</span>]^<span class="number">3</span>+<span class="number">1</span>)%p*inverse(G[<span class="number">0</span>]*G[<span class="number">1</span>],p)%p</span><br></pre></td></tr></table></figure>

<p>利用G和Q构造方程解出a</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="number">55099055368053948610276786301</span></span><br><span class="line">Gx = <span class="number">19663446762962927633037926740</span></span><br><span class="line">Gy = <span class="number">35074412430915656071777015320</span></span><br><span class="line">Qx = <span class="number">26805137673536635825884330180</span></span><br><span class="line">Qy = <span class="number">26376833112609309475951186883</span></span><br><span class="line"><span class="comment"># 计算 Gy^3 + 1 mod p</span></span><br><span class="line">Gy_cubed = <span class="built_in">pow</span>(Gy, <span class="number">3</span>, p)</span><br><span class="line">Gy_cubed_plus_1 = (Gy_cubed + <span class="number">1</span>) % p</span><br><span class="line"><span class="comment"># 计算 Qy^3 + 1 mod p</span></span><br><span class="line">Qy_cubed = <span class="built_in">pow</span>(Qy, <span class="number">3</span>, p)</span><br><span class="line">Qy_cubed_plus_1 = (Qy_cubed + <span class="number">1</span>) % p</span><br><span class="line"><span class="comment"># 计算分子：(Gy^3+1)*Qx*Qy - (Qy^3+1)*Gx*Gy mod p</span></span><br><span class="line">term1 = (Gy_cubed_plus_1 * Qx) % p</span><br><span class="line">term1 = (term1 * Qy) % p</span><br><span class="line">term2 = (Qy_cubed_plus_1 * Gx) % p</span><br><span class="line">term2 = (term2 * Gy) % p</span><br><span class="line">numerator = (term1 - term2) % p</span><br><span class="line"><span class="comment"># 计算分母：Qx^3*Gx*Gy - Gx^3*Qx*Qy mod p</span></span><br><span class="line">Qx_cubed = <span class="built_in">pow</span>(Qx, <span class="number">3</span>, p)</span><br><span class="line">term3 = (Qx_cubed * Gx) % p</span><br><span class="line">term3 = (term3 * Gy) % p</span><br><span class="line">Gx_cubed = <span class="built_in">pow</span>(Gx, <span class="number">3</span>, p)</span><br><span class="line">term4 = (Gx_cubed * Qx) % p</span><br><span class="line">term4 = (term4 * Qy) % p</span><br><span class="line">denominator = (term3 - term4) % p</span><br><span class="line"><span class="comment"># 计算逆元</span></span><br><span class="line">inv_denominator = <span class="built_in">pow</span>(denominator, -<span class="number">1</span>, p)</span><br><span class="line">a = (numerator * inv_denominator) % p</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#a=39081810733380615260725035189</span></span><br></pre></td></tr></table></figure>

<p>求得a的值构建出椭圆曲线后使用 Pohlig Hellman 即可解出 Q &#x3D; xG 中的 x</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">a = <span class="number">39081810733380615260725035189</span></span><br><span class="line">p = <span class="number">55099055368053948610276786301</span></span><br><span class="line">P = (<span class="number">19663446762962927633037926740</span>, <span class="number">35074412430915656071777015320</span>)</span><br><span class="line">Q = (<span class="number">26805137673536635825884330180</span>, <span class="number">26376833112609309475951186883</span>)</span><br><span class="line">d = (a * Q[<span class="number">0</span>] ** <span class="number">3</span> + Q[<span class="number">1</span>] ** <span class="number">3</span> + <span class="number">1</span>) * inverse(Q[<span class="number">0</span>] * Q[<span class="number">1</span>], p) % p</span><br><span class="line"><span class="comment"># construct ECC to get a solution of aX^3+Y^3+Z^3=dXYZ</span></span><br><span class="line">R.&lt;x,y,z&gt; = Zmod(p)[]</span><br><span class="line">cubic = a * x^<span class="number">3</span> + y^<span class="number">3</span> + z^<span class="number">3</span> - d*x*y*z</span><br><span class="line">E = EllipticCurve_from_cubic(cubic,morphism=<span class="literal">True</span>)</span><br><span class="line">P = E(P)</span><br><span class="line">Q = E(Q)</span><br><span class="line">P_ord = P.order()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Pohlig_Hellman</span>(<span class="params">n, P, Q</span>):</span><br><span class="line">    <span class="keyword">return</span> discrete_log(Q, P, <span class="built_in">ord</span>=n, operation=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">x = Pohlig_Hellman(P_ord,P,Q)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#x=2633177798829352921583206736</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line">x = <span class="number">2633177798829352921583206736</span></span><br><span class="line">key = hashlib.sha256(<span class="built_in">str</span>(x).encode()).digest()</span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">ciphertext = <span class="string">b&quot;k\xe8\xbe\x94\x9e\xfc\xe2\x9e\x97\xe5\xf3\x04&#x27;\x8f\xb2\x01T\x06\x88\x04\xeb3Jl\xdd Pk$\x00:\xf5&quot;</span></span><br><span class="line">decrypted_flag = unpad(cipher.decrypt(ciphertext), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;解密后的数据: <span class="subst">&#123;decrypted_flag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#解密后的数据: b&#x27;hgame&#123;N0th1ng_bu7_up_Up_UP!&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Spica"><a href="#3-Spica" class="headerlink" title="3.Spica"></a>3.Spica</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, long_to_bytes,bytes_to_long</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_M</span>(<span class="params">n</span>):</span><br><span class="line">    iota=<span class="number">0.035</span></span><br><span class="line">    Mbits=<span class="built_in">int</span>(<span class="number">2</span> * iota * n^<span class="number">2</span> + n * log(n,<span class="number">2</span>))</span><br><span class="line">    M = random_prime(<span class="number">2</span>^Mbits, proof = <span class="literal">False</span>, lbound = <span class="number">2</span>^(Mbits - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> Integer(M)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag).bit_length()</span><br><span class="line">n = <span class="number">70</span></span><br><span class="line">p = derive_M(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F = GF(p)</span><br><span class="line">x = random_matrix(F, <span class="number">1</span>, n)</span><br><span class="line">A = random_matrix(ZZ, n, m, x=<span class="number">0</span>, y=<span class="number">2</span>)</span><br><span class="line">A[randint(<span class="number">0</span>, n-<span class="number">1</span>)] = vector(ZZ, <span class="built_in">list</span>(<span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:]))</span><br><span class="line">h = x*A</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="built_in">str</span>(m) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(p) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> h:</span><br><span class="line">        file.write(<span class="built_in">str</span>(item) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>隐子集和问题（HSSP &#x2F; Hidden Subset Sum Problem）。解题参考：<a href="https://yanmo312.github.io/2022/11/26/gemima_6/#%E4%B8%89%E3%80%81%E9%9A%90%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88HSSP-Hidden-Subset-Sum-Problem%EF%BC%89">https://yanmo312.github.io/2022/11/26/gemima_6/#%E4%B8%89%E3%80%81%E9%9A%90%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88HSSP-Hidden-Subset-Sum-Problem%EF%BC%89</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        m = <span class="built_in">int</span>(f.readline().strip())</span><br><span class="line">        n = <span class="number">70</span></span><br><span class="line">        p = <span class="built_in">int</span>(f.readline().strip())</span><br><span class="line">        h_line = f.readline().strip() </span><br><span class="line">        w = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, h_line[<span class="number">1</span>:-<span class="number">1</span>].split(<span class="string">&#x27;, &#x27;</span>))) </span><br><span class="line">    <span class="keyword">return</span> m, n, p, w</span><br><span class="line"><span class="comment"># 生成 orthoLattice 的相关函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orthoLattice</span>(<span class="params">b, x0</span>):</span><br><span class="line">    m = b.length()</span><br><span class="line">    M = Matrix(ZZ, m, m)</span><br><span class="line">    <span class="comment"># 生成正交矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        M[i, i] = <span class="number">1</span></span><br><span class="line">    M[<span class="number">1</span>:m, <span class="number">0</span>] = -b[<span class="number">1</span>:m] * inverse_mod(b[<span class="number">0</span>], x0)</span><br><span class="line">    M[<span class="number">0</span>, <span class="number">0</span>] = x0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        M[i, <span class="number">0</span>] = mod(M[i, <span class="number">0</span>], x0)</span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allpmones</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>([vj <span class="keyword">for</span> vj <span class="keyword">in</span> v <span class="keyword">if</span> vj <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]) == <span class="built_in">len</span>(v)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allones</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(vj <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> vj <span class="keyword">in</span> v):</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(vj <span class="keyword">in</span> (<span class="number">0</span>, -<span class="number">1</span>) <span class="keyword">for</span> vj <span class="keyword">in</span> v):</span><br><span class="line">        <span class="keyword">return</span> -v</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 恢复只包含 &#123;0,1&#125; 或 &#123;-1,0,1&#125; 的向量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recoverBinary</span>(<span class="params">M5</span>):</span><br><span class="line">    lv = [allones(vi) <span class="keyword">for</span> vi <span class="keyword">in</span> M5 <span class="keyword">if</span> allones(vi)]</span><br><span class="line">    n = M5.nrows()</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> lv:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nv = allones(M5[i] - v)</span><br><span class="line">            <span class="keyword">if</span> nv <span class="keyword">and</span> nv <span class="keyword">not</span> <span class="keyword">in</span> lv:</span><br><span class="line">                lv.append(nv)</span><br><span class="line">            nv = allones(M5[i] + v)</span><br><span class="line">            <span class="keyword">if</span> nv <span class="keyword">and</span> nv <span class="keyword">not</span> <span class="keyword">in</span> lv:</span><br><span class="line">                lv.append(nv)</span><br><span class="line">    <span class="keyword">return</span> Matrix(lv)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kernelLLL</span>(<span class="params">M</span>):</span><br><span class="line">    n = M.nrows()</span><br><span class="line">    m = M.ncols()</span><br><span class="line">    <span class="keyword">if</span> m &lt; <span class="number">2</span> * n:</span><br><span class="line">        <span class="keyword">return</span> M.right_kernel().matrix()</span><br><span class="line">    K = <span class="number">2</span> ^ (m // <span class="number">2</span>) * M.height()</span><br><span class="line">    MB = Matrix(ZZ, m + n, m)</span><br><span class="line">    MB[:n] = K * M</span><br><span class="line">    MB[n:] = identity_matrix(m)</span><br><span class="line">    MB2 = MB.T.LLL().T</span><br><span class="line">    <span class="keyword">assert</span> MB2[:n, : m - n] == <span class="number">0</span></span><br><span class="line">    Ke = MB2[n:, : m - n].T</span><br><span class="line">    <span class="keyword">return</span> Ke</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">m, n, p, w</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>, n, <span class="string">&quot;m =&quot;</span>, m)</span><br><span class="line">    iota = <span class="number">0.035</span></span><br><span class="line">    nx0 = <span class="built_in">int</span>(<span class="number">2</span> * iota * n^<span class="number">2</span> + n * log(n, <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nx0 =&quot;</span>, nx0)</span><br><span class="line">    x0 = p</span><br><span class="line">    b = vector(w)</span><br><span class="line">    M = orthoLattice(b, x0)</span><br><span class="line">    t = time.time()</span><br><span class="line">    M2 = M.LLL()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LLL step1: %.1f&quot;</span> % (time.time() - t))</span><br><span class="line">    MOrtho = M2[: m - n]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;log(Height, 2) = &quot;</span>, <span class="built_in">int</span>(log(MOrtho.height(), <span class="number">2</span>)))</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    ke = kernelLLL(MOrtho)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Kernel: %.1f&quot;</span> % (time.time() - t2))</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">170</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    beta = <span class="number">2</span></span><br><span class="line">    tbk = time.time()</span><br><span class="line">    <span class="keyword">while</span> beta &lt; n:</span><br><span class="line">        <span class="keyword">if</span> beta == <span class="number">2</span>:</span><br><span class="line">            M5 = ke.LLL()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            M5 = M5.BKZ(block_size=beta)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>([<span class="literal">True</span> <span class="keyword">for</span> v <span class="keyword">in</span> M5 <span class="keyword">if</span> allpmones(v)]) == n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> beta == <span class="number">2</span>:</span><br><span class="line">            beta = <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            beta += <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BKZ beta=%d: %.1f&quot;</span> % (beta, time.time() - tbk))</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    MB = recoverBinary(M5)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Recovery: %.1f&quot;</span> % (time.time() - t2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number of recovered vector = &quot;</span>, MB.nrows())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number of recovered vector.T = &quot;</span>, MB.ncols())</span><br><span class="line">    <span class="keyword">return</span> MB</span><br><span class="line">m, n, p, w = read_data(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">res = attack(m, n, p, w)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bits_to_long</span>(<span class="params">bits</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(bit) <span class="keyword">for</span> bit <span class="keyword">in</span> bits), <span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_flags</span>(<span class="params">MB</span>):</span><br><span class="line">    flags = []</span><br><span class="line">    <span class="comment"># 遍历 MB 的每一行，将每一行转换为一个二进制数字</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> MB:</span><br><span class="line">        flag_bits = [<span class="built_in">int</span>(element) <span class="keyword">for</span> element <span class="keyword">in</span> row]  <span class="comment"># 获取每行的二进制位</span></span><br><span class="line">        flag_long = bits_to_long(flag_bits)  <span class="comment"># 转换为整数</span></span><br><span class="line">        flag = long_to_bytes(flag_long)  <span class="comment"># 转换为字节串</span></span><br><span class="line">        flags.append(flag)    </span><br><span class="line">    <span class="keyword">return</span> flags</span><br><span class="line">flags = extract_flags(res)</span><br><span class="line"><span class="keyword">for</span> flag <span class="keyword">in</span> flags:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Recovered flag: <span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#Recovered flag: b&#x27;hgame&#123;U_f0und_3he_5pec14l_0n3!&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>感觉代码最后加个对flag的处理，判断只有符合hgame{}格式的flag输出会好点（但数据不是很大，还是一眼就从输出里找到正确flag）。输出部分还是很好找的是吧（</p>
<p>最后说明这是第一次尝试写wp，肯定有很多不足之处，会继续在日后一点一点完善这个过程。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>格密码学初步学习</title>
    <url>/2025/01/22/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>懒惰的我终于开始初步学习密码学中格的相关内容了，虽然很早之前就看过了，但是由于东西实在是太多了根本看不下去，看了也不理解。现在再次开始密码学之路，这篇文章算是边学边理解的感悟吧。</p>
<h1 id="格的认识"><a href="#格的认识" class="headerlink" title="格的认识"></a>格的认识</h1><p>经过学长的点明后，对于我目前学习最初步的格来说就把格理解为线性向量，把线性代数的知识运用上去，无非就是换了很多全新的名词，本质上按线性向量去理解会轻松很多。所以说还是要有一定线代基础不然还是很难接受（但线代本身也确实很抽象😢）</p>
<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><p>目前看过来分为svp（shortest vector problem）最短向量问题和cvp（closest vector problem)最近向量问题。两个名字看中文感觉就是一回事最短和最近，但事实上区别很大。</p>
<h3 id="SVP"><a href="#SVP" class="headerlink" title="SVP"></a>SVP</h3><p>感觉正式讲法很难理解，我自己想法就是格中有一组基向量【b1，b2】以及很多点，要通过基向量找到一个点，使得这个点离原点最近，而λ1就是最短向量。有时候因为基的点分布并不理想，很多时候找出来的是最短向量λ1的倍数，这就是svp的宽松版本了。<img src="/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/svp.png" alt="svp"></p>
<h3 id="CVP"><a href="#CVP" class="headerlink" title="CVP"></a>CVP</h3><p>在基中找一个点t，找到距离这个点最近的格点。换句话理解就是找到一个向量λ1使得t向量（蓝色线）与λ1相减后得到的向量μ最短。同样存在cvp的宽松版本，如图中2μ，只不过目前我对于宽松版本还未很好理解。<img src="/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/cvp.png" alt="cvp"></p>
<h2 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h2><p>嗯感觉这个原理非常复杂，想理解目前水平做不到，差不多想就是LLL是一个格基约化算法，作用是将上面图片中格变得更加整齐（就是把图中倾斜绿色点变得和坐标轴一样整齐）。反正目前做一些初步题大概就是按题目意思构造一个合理的格然后对格直接用LLL.( )会得到一个短向量，然后从这些向量中可以找到我们需要的，然后差不多就可以解出题目。所以不需要理解直接用吧😢然后顺带提一下BKZ算法，也是理解为更高级的LLL，直接用别管原理什么的。</p>
]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
</search>
